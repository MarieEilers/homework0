# Data Camp Base R

## Using variables 1
### What is the sum of the first  positive integers?
# Here is how you compute the sum for the first 20 integers
20*(20+1)/2 

# However, we can define a variable to use the formula for other values of n
n <- 20
n*(n+1)/2

n <- 25
n*(n+1)/2

# Below, write code to calculate the sum of the first 100 integers
n <- 100
n*(n+1)/2

# Below, write code to calculate the sum of the first 1000 integers 
n<- 1000
n*(n+1)/2

# Functions
## Run the following code in the R console:
  
n <- 1000
x <- seq(1,n)
sum(x)
## Based on the result, what do you think the functions seq and sum do? You can use the help system.
## seq creates a list of numbers and sum adds them up.



# Nested function calls 1
## In math and programming we say we evaluate a function when we replace arguments with specific values. So if we type log2(16) we evaluate the log2 function to get the log base 2 of 16 which is 4.
## In R it is often useful to evaluate a function inside another function. For example, sqrt(log2(16)) will calculate the log to the base 2 of 16 and then compute the square root of that value. So the first evaluation gives a 4 and this gets evaluated by sqrt to give the final answer of 2.

# log to the base 2 
log2(16)

# sqrt of the log to the base 2 of 16:
sqrt(log2(16))

# Compute log to the base 10 (log10) of the sqrt of 100. Do not use variables.
log10(100)
sqrt(log10(100))

# Nested functions call 2
## Which of the following will always return the numeric value stored in x? You can try out examples and use the help system in the R console.

##log(10^x)

##log10(x^10)

log(exp(x))

##exp(log(x, base = 2))

# Data Camp 2
#str
## We're going to be using the following dataset for this module. Run this code in the console.

library(dslabs)
data(murders)
##Next, use the function str to examine the structure of the murders object. We can see that this object is a data frame with 51 rows and five columns.
#Which of the following best describes the variables represented in this data frame:


## The 51 states

##The murder rates for all 50 states and DC
##The state name, the abbreviation of the state name, the state's region, and the state's population and the total number of murders for 2010.

##str shows no relevant information

##Variable names
##In the previous question, we saw the different variables that are a part of this dataset from the output of the str() function. The function names() is specifically designed to extract the column names from a data frame.

# Load package and data

library(dslabs)
data(murders)

# Use the function names to extract the variable names 
names (murders)

##Examining Variables
###In this module we have learned that every variable has a class. For example, the class can be a character, numeric or logical. The function class() can be used to determine the class of an object.

###Here we are going to determine the class of one of the variables in the murders data frame. To extract variables from a data frame we use $, referred to as the accessor.

###In the editor we show an example of how to do this. Let`s try it out for ourselves.


# To access the population variable from the murders dataset use this code:
p <- murders$population 

# To determine the class of object `p` we use this code:
class(p)

# Use the accessor to extract state abbreviations and assign it to a
a<-murders$abb
# Determine the class of a
class(a)


###There are also multiple ways to access variables in a data frame. For example we can use the square brackets [[ instead of the accessor $. Example code is included in the editor.

###If you instead try to access a column with just one bracket,

murders["population"]
### R returns a subset of the original data frame containing just this column. This new object will be of class data.frame rather than a vector. To access the column itself you need to use either the $ accessor or the double square brackets [[.
                                                                                                                                                                                                                                               
# We extract the population like this:
p <- murders$population

# This is how we do the same with the square brackets:
o <- murders[["population"]] 

# We can confirm these two are the same
identical(o, p)

# Use square brackets to extract `abb` from `murders` and assign it to b
b <- murders[["abb"]]
# Check if `a` and `b` are identical 
identical (a, b)
#Parentheses, in contrast, are mainly used alongside functions to indicate what argument the function should be doing something to. For example, when we did class(p) in the last question, we wanted the function class to do something related to the argument p.
                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                               This is an example of how R can be a bit idiosyncratic sometimes. It is very common to find it confusing at first.












